---
date: 2025-08-24
title: Sending Metrics from your frontend application
id: sending-metrics-frontend
---

This documentation provides steps for sending metrics from your frontend application to SigNoz.

SigNoz natively supports OpenTelemetry for collecting metrics, so you can lift-and-shift existing log libraries or build new pipelines, all with the same unified model as your traces and logs.

Metrics can be collected on the client side at meaningful points to capture various events and state changes.

## Prerequisites

- [SigNoz Cloud](https://signoz.io/teams/) or self-hosted account
- A web application from where you want to send metrics

## Setup

### Step 1: Setup OTel Collector

Install the OpenTelemetry Collector binary using [these instructions](https://signoz.io/docs/tutorial/opentelemetry-binary-usage-in-virtual-machine/). The Collector acts as an agent that receives, processes, and exports telemetry data. It is required to collect data from your application, including metrics.

You would also need to update the collector config to whitelist the frontend domain. This is required to allow Cross-Origin Resource Sharing (CORS) requests from your frontend application to the OpenTelemetry collector.

```sh
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
      http:
        endpoint: 0.0.0.0:4318
        cors:
          allowed_origins:
            - <<YOUR_FRONTEND_URL>>
          allowed_headers: ['*']
```

### Step 2: Install dependencies

Install the following dependencies.

<Tabs entityName="metrics-dependencies">
  <TabItem value="npm" label="Npm">
    ```sh
    npm i \
      @opentelemetry/resources \
      @opentelemetry/sdk-metrics \
      @opentelemetry/exporter-metrics-otlp-http \
      @opentelemetry/api
    ```
  </TabItem>
  <TabItem value="yarn" label="Yarn" default>
    ```sh
    yarn add \
      @opentelemetry/resources \
      @opentelemetry/sdk-metrics \
      @opentelemetry/exporter-metrics-otlp-http \
      @opentelemetry/api
    ```
  </TabItem>
</Tabs>

<details>
<summary> Read more about the dependencies </summary>
- **`@opentelemetry/resources`**: Provides resource attributes that identify your service (like service name, version, etc.). This helps distinguish metrics from different services in your SigNoz dashboard.

- **`@opentelemetry/sdk-metrics`**: Contains the core metrics SDK implementation including `MeterProvider` and `PeriodicExportingMetricReader`. This is the foundation for creating and sending metrics from your application.

- **`@opentelemetry/exporter-metrics-otlp-http`**: Implements the OTLP (OpenTelemetry Protocol) HTTP exporter that sends your metrics to the SigNoz collector. This handles the actual transmission of metrics data over HTTP.

- **`@opentelemetry/api-metrics`**: Provides the API interface that your application code uses to create metrics. This is the main API you'll interact with when adding metrics to your code.
</details>

### Step 3: Create an instrumentation file

The instrumentation file is required to setup the `MeterProvider` which is used to create custom metrics within your application and export them to your collector.
Inside your `src` directory, create a file named `instrument.js` (or `instrument.ts` for TypeScript):

<Tabs entityName="logs-instrumentation">
  <TabItem value="cloud" label="SigNoz Cloud" default>
    ```ts:instrument.js
      import {
        MeterProvider,
        PeriodicExportingMetricReader,
      } from '@opentelemetry/sdk-metrics';
      import { OTLPMetricExporter } from '@opentelemetry/exporter-metrics-otlp-http';
      import { resourceFromAttributes } from '@opentelemetry/resources';
      import { metrics } from '@opentelemetry/api';

      // Define your resource, e.g., service name, environment.
      const resource = resourceFromAttributes({
        'service.name': <<SERVICE_NAME>>,
      });

      // Create a metric reader with OTLP exporter configured to send metrics to a local collector.
      const metricReader = new PeriodicExportingMetricReader({
        exporter: new OTLPMetricExporter({
          url: `https://ingest.<<INGESTION_REGION>>.signoz.cloud:443/v1/metrics`,
          headers: {
            'signoz-ingestion-key': <<INGESTION_KEY>>,
          },
        }),
        exportIntervalMillis: 10000, // Export metrics every 10 seconds.
      });

      // Initialize a MeterProvider with the above configurations.
      const myServiceMeterProvider = new MeterProvider({
        resource,
        readers: [metricReader],
      });

      // Set the initialized MeterProvider as global to enable metric collection across the app.
      metrics.setGlobalMeterProvider(myServiceMeterProvider);
    ```

    - Set the `<<INGESTION_REGION>>` to match your SigNoz Cloud [region](https://signoz.io/docs/ingestion/signoz-cloud/overview/#endpoint)
    - Replace `<<INGESTION_KEY>>` with your SigNoz [ingestion key](https://signoz.io/docs/ingestion/signoz-cloud/keys/)
    - `<<SERVICE_NAME>>` is the name of your service
  </TabItem>
  <TabItem value="self-hosted" label="SigNoz Self-Hosted">
    ```ts:instrument.js
      import {
        MeterProvider,
        PeriodicExportingMetricReader,
      } from '@opentelemetry/sdk-metrics';
      import { OTLPMetricExporter } from '@opentelemetry/exporter-metrics-otlp-http';
      import { resourceFromAttributes } from '@opentelemetry/resources';
      import { metrics } from '@opentelemetry/api';

      // Define your resource, e.g., service name, environment.
      const resource = resourceFromAttributes({
        'service.name': <<SERVICE_NAME>>,
      });

      // Create a metric reader with OTLP exporter configured to send metrics to a local collector.
      const metricReader = new PeriodicExportingMetricReader({
        exporter: new OTLPMetricExporter({
          url: '<<SIGNOZ_COLLECTOR_URL>>/v1/metrics',
        }),
        exportIntervalMillis: 10000, // Export metrics every 10 seconds.
      });

      // Initialize a MeterProvider with the above configurations.
      const myServiceMeterProvider = new MeterProvider({
        resource,
        readers: [metricReader],
      });

      // Set the initialized MeterProvider as global to enable metric collection across the app.
      metrics.setGlobalMeterProvider(myServiceMeterProvider);
    ```

    - `<<SERVICE_NAME>>` is the name of your service
    - `<<SIGNOZ_COLLECTOR_URL>>` is the url where your collector is running
  </TabItem>
</Tabs>

### Step 4: Importing the instrumentation file

Import the instrumentation file at the top level of your application. This ensures that the OpenTelemetry instrumentation is initialized before any other code runs, allowing it to capture metrics from the very beginning of your application's execution.

```ts
import './instrument';
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import './index.css';
import App from './App';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>
);
```

### Step 5: Setting up Metrics within your Application

Now you can create and record metrics in your application. Here's an example of how to create and use metrics.

```ts
import { metrics } from '@opentelemetry/api';

// Get a meter from the global meter provider
const meter = metrics.getMeter('my-app-metrics');

// Create a histogram metric for measuring request duration (also gives count & sum)
const requestDuration = meter.createHistogram('http.client.request.duration', {
  description: 'Duration of HTTP requests',
  unit: 's', // seconds
});

// Record metrics in your application
async function handleRequest() {
  const startTime = performance.now();
  
  try {
    const response = await fetch('/api/data', { method: 'GET' });

    // Record the request duration
    const duration = (performance.now() - startTime) / 1000; // Convert to seconds
    requestDuration.record(duration, {
      'http.request.method': 'GET',
      'http.response.status_code': response.status,
      'http.route': '/api/data',
      'url.path': '/api/data',
      'url.scheme': window.location.protocol.replace(':', ''),
    });

    return await response.json();
  } catch (err) {
    const duration = (performance.now() - startTime) / 1000; // Convert to seconds
    requestDuration.record(duration, {
      'http.request.method': 'GET',
      'http.response.status_code': 0,
      'http.route': '/api/data',
      'url.path': '/api/data',
      'url.scheme': window.location.protocol.replace(':', ''),
    });
    throw err;
  }
}
```

### Step 6: Viewing Captured Metrics in SigNoz

The captured metrics can then be viewed in the [Metrics Explorer](https://signoz.io/docs/metrics-management/metrics-explorer/).

<figure data-zoomable align="center">
  <img
    className="box-shadowed-image"
    src="/img/guides/2025/frontend-monitoring/sending-metrics/metrics-explorer-view.webp"
    alt="SigNoz Metrics Explorer"
  />
  <figcaption>
    <i>SigNoz Metrics Explorer</i>
  </figcaption>
</figure>

## Demo Application  
Check out this [Sample React Application](https://github.com/SigNoz/frontend-monitoring-examples/tree/main/sending-metrics) that demonstrates sending metrics to SigNoz.